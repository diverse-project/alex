behavior activitydiagram_exec

import activitydiagramruntime.Token
import activitydiagram.ActivityNode
import java.util.List
import activitydiagramruntime.Context
import activitydiagramruntime.Offer
import activitydiagram.ActivityEdge
import activitydiagram.ControlFlow
import activitydiagram.InputValue
import activitydiagram.InitialNode
import java.io.IOException
import activitydiagram.Value
import activitydiagram.Variable
import activitydiagramruntime.ForkedToken
import activitydiagram.BooleanValue
import activitydiagram.IntegerValue
import activitydiagramruntime.ActivitydiagramruntimeFactory
import java.io.BufferedWriter
import java.io.OutputStreamWriter
import java.io.FileOutputStream
import java.io.File
import org.eclipse.emf.common.util.URI

import ecore "platform:/resource/org.xtext.activitydiagram.ale.semantics.model/model/activitydiagramruntime.ecore"


open class ForkNode {
	override void execute(Context c) {
		c.output.executedNodes.add(obj)
		var tokens = alg.$(obj).takeOfferdTokens
		var forkedTokens = newArrayList
		for (Token token : tokens) {
			var forkedToken = ActivitydiagramruntimeFactory.eINSTANCE.createForkedToken
			forkedToken.baseToken = token
			forkedToken.remainingOffersCount = obj.outgoing.size
			forkedTokens.add(forkedToken);
		}
		alg.$(obj).addTokens(forkedTokens)
		alg.$(obj).sendOffers(forkedTokens)
	}
}
open abstract class Variable {
	abstract def void execute(Context c)
	abstract def  void init(Context c)
	abstract def String print()
	abstract def String name()
}

open abstract class Exp {
	// DONE
	abstract def void execute(Context c)
}
open class DecisionNode {
	override void execute(Context c) {
		c.output.executedNodes.add(obj)
		alg.$(obj).sendOffers(alg.$(obj).takeOfferdTokens)

	}
	
	override void sendOffers(List<Token> tokens) {
		for (ActivityEdge edge : obj.outgoing) {
			if (edge instanceof ControlFlow && ( edge as ControlFlow).guard !== null) {
				if ((( edge as ControlFlow).guard.currentValue as BooleanValue).value) {
					alg.$(edge).sendOffer(tokens);
				}
			}
		}
	}
}
open class FinalNode {
	// DONE
}
open class InitialNode {
	override void execute(Context c) {
		var r = ActivitydiagramruntimeFactory.eINSTANCE.createControlToken
		r.holder = obj
		var list = newArrayList
		list.add(r)
		alg.$(obj).sendOffers(list)
		c.output.executedNodes.add(obj)
	}
	
	override boolean hasOffers() {
//		println('hasOffers ' + obj.name + ': '+ false)
		return false
	}
}
open class ControlFlow {
	// done
}
open class Action {
	// done
}

open class ControlNode {
	// done
}
open class OpaqueAction {

	override void execute(Context c) {
		c.output.executedNodes.add(obj)
		obj.expressions.forEach [
			alg.$(it).execute(c)
		]
		alg.$(obj).sendOffers(alg.$(obj).takeOfferdTokens)
	}
}
open class Input {
	// done
}

open class ActivityEdge {

	def List<Offer> offers() {
		
		val res = obj.eResource
		val allContent = res.resourceSet.allContents
		val offers = allContent.filter(Offer)
		val owneds = offers.filter[it.owned == obj]
		val ret = owneds.toList
		
//		val ret = obj.eCrossReferences.filter(Offer).toList
//		println('offers = ' + obj.name + ' -> ' + ret)
		ret
	}
	def void sendOffer(List<Token> tokens) {
//		println('{{ sendOffer ' + tokens)
		val offer = ActivitydiagramruntimeFactory.eINSTANCE.createOffer
		tokens.forEach[offer.offeredTokens.add(it)]
		
		val res = obj.eResource.resourceSet.createResource(URI.createURI('offer'+ offer.hashCode +'.xml'))

//		alg.$(obj).offers.add(offer)eCross
		offer.owned = obj
		
		
		res.contents += offer
	}

	def List<Token> takeOfferedTokens() {
		val tokens = newArrayList
		alg.$(obj).offers.forEach[tokens.addAll(it.offeredTokens)]
		alg.$(obj).offers.clear();
		return tokens
	}

	def boolean hasOffer() {
//		println('>hasOffer ActivityEdge ' + obj.name)
		val ret = alg.$(obj).offers.exists[
//			println('offer??')
			alg.$(it).hasTokens
		]
//		println('<hasOffer ActivityEdge ' + obj.name + ' ' + ret )
		ret
	}
}
open class ExecutableNode {
	// done
}
open abstract class Value {
	// done
}

open class ActivityFinalNode {
	override void execute(Context c) {
		c.output.executedNodes.add(obj)
		alg.$(obj).sendOffers(alg.$(obj).takeOfferdTokens)
	}
}
open class MergeNode {
	override void execute(Context c) {
		c.output.executedNodes.add(obj)
		alg.$(obj).sendOffers(alg.$(obj).takeOfferdTokens)

	}
	override boolean hasOffers() {
		val ret = obj.incoming.exists[alg.$(it).hasOffer]
//		println('hasOffers MergeNode ' + obj.name + ': '+ ret)
		ret
	}
}



open class NamedActivity {
	//done
}

open class ActivityNode {
	
	
	def List<Token> heldTokens() {
//		obj.eCrossReferences.filter(Token).toList
		
		val res = obj.eResource
		val allContent = res.resourceSet.allContents
		val offers = allContent.filter(Token)
		val owneds = offers.filter[it.holder == obj]
		val ret = owneds.toList
		
		ret
	}
	def void execute(Context c) {
		// obj.sendOffers1(obj.takeOfferdTokens1)
	}

	def void terminate() {
		obj.running = false
	}

	def boolean isReady() {
		return obj.isRunning
	}

	def void sendOffers(List<Token> tokens) {
		obj.outgoing.forEach[alg.$(it).sendOffer(tokens)]
	}

	def List<Token> takeOfferdTokens() {
		val allTokens = newArrayList
		obj.getIncoming.forEach [
			val tokens = alg.$(it).takeOfferedTokens
			for (Token token : tokens) {
				alg.$(token).withdraw
				token.holder = obj
			}
			allTokens.addAll(tokens);
		]
		return allTokens
	}

	def void addTokens(List<Token> tokens) {
		for (Token token : tokens) {
			var transferredToken = alg.$(token).transfer(obj);
			alg.$(obj).heldTokens.add(transferredToken);
		}
	}

	def boolean hasOffers() {
		var hasOffer = true
		for (ActivityEdge edge : obj.incoming) {
//			println('>')
			if (!alg.$(edge).hasOffer) {
				hasOffer = false
			}
//			println('<')
		}
		
//		println('hasOffers ActivityNode ' + obj.name + ': '+ hasOffer)
		return hasOffer
	}

	def void removeToken(Token token) {
		alg.$(obj).heldTokens.remove(token);
	}
}



open class Activity {
	
//	def Trace trace() {
////		return obj.eCrossReferences.filter(Trace).head
//
//		val res = obj.eResource
//		val allContent = res.resourceSet.allContents
//		val offers = allContent.filter(Trace)
//		offers.findFirst[it.executedNodes.contains(obj)]
//	}
	
	def void main(List<InputValue> value) {
		var c = ActivitydiagramruntimeFactory.eINSTANCE.createContext
		c.inputValues += value
		c.activity = obj
		val trace = ActivitydiagramruntimeFactory.eINSTANCE.createTrace
		c.output = trace
		value?.forEach[v|
			v.getVariable().setCurrentValue(v.getValue())
		]
		obj.nodes.forEach[n|n.running=true]
		alg.$(obj).execute(c)
	}

	def void execute(Context c) {
		obj.locals.forEach[v|alg.$(v).init(c)]
		alg.$(obj.nodes.filter[node|node instanceof InitialNode].get(0)).execute(c)
		
		var list =  obj.nodes.filter[node|alg.$(node).hasOffers]
		while (list!==null && list.size>0 ){
			alg.$(list.get(0)).execute(c)
			list =  obj.nodes.filter[node|alg.$(node).hasOffers]
			
			println(c.output.executedNodes.size)
			
		}
	}

	def void reset(Context c) {
		c.output = null
	}

	def void writeToFile(Context c) {
		var text = alg.$(obj).printTrace(c)
		try {
			var writer = new BufferedWriter(new OutputStreamWriter(
				new FileOutputStream(new File("trace/" + obj.getName() + ".txt"))));
			writer.write(text);
			writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	def String printTrace(Context c) {
		val text = new StringBuffer();
		c.output.executedNodes.forEach[n|text.append(n.name); text.append(System.getProperty("line.separator"));]

		obj.getLocals().forEach [ v |
			text.append(alg.$(v).print)
			text.append(System.getProperty("line.separator"))
		]
		return text.toString
	}

	def int getIntegerVariableValue(String variableName) {
		var currentValue = alg.$(obj).getVariableValue(variableName)
		if (currentValue instanceof IntegerValue) {
			return currentValue.value
		}
		return -1
	}

	def boolean getBooleanVariableValue(String variableName) {
		var currentValue = alg.$(obj).getVariableValue(variableName);
		if (currentValue instanceof BooleanValue) {
			return currentValue.isValue
		}
		return false;
	}

	def Value getVariableValue(String variableName) {
		var variable = alg.$(obj).getVariable(variableName)
		var currentValue = variable.getCurrentValue()
		return currentValue
	}

	def Variable getVariable(String variableName) {
		var allVariables = newArrayList
		allVariables.addAll(obj.locals);
		allVariables.addAll(obj.inputs);
		for (Variable var1 : allVariables) {
			if (alg.$(var1).name().equals(variableName)) {
				return var1
			}
		}
		return null
	}

	def void writeTrace(Context c) {
		alg.$(obj).writeToFile(c)
		alg.$(obj).reset(c)
	}
}

open class JoinNode {
	override void execute(Context c) {
		c.output.executedNodes.add(obj)
		var tokens = alg.$(obj).takeOfferdTokens
		tokens.forEach[t| if ((t as ForkedToken).remainingOffersCount>1){
			(t as ForkedToken).remainingOffersCount = (t as ForkedToken).remainingOffersCount -1
		}else{
			var list = newArrayList
			list.add(t)
			alg.$(obj).sendOffers(list)
		}
		]
	}
}

open class Offer {

	def boolean hasTokens() {
		removeWithdrawnTokens
		return !obj.offeredTokens.empty
	}

	def void removeWithdrawnTokens() {
		val List<Token> tokensToBeRemoved = newArrayList
		obj.offeredTokens.forEach [
			val sem = alg.$(it)
			if (sem.withdrawn) {
				tokensToBeRemoved.add(it)
			}
		]
		obj.offeredTokens.removeAll(tokensToBeRemoved)
	}

}

 open class Token {

	def Token transfer(ActivityNode holder) {
		if (obj.holder !== null) {
			alg.$(obj).withdraw
		}
		obj.holder = holder;
		return obj
	}

	def void withdraw() {
		if (!alg.$(obj).isWithdrawn) {
			alg.$(obj.holder).removeToken(obj);
			obj.holder = null
		}
	}

	def boolean isWithdrawn() {
		return obj.holder === null
	}
}

open class ForkedToken {
	// done
}

open class ControlToken {
	// done
}

open class InputValue {

}



open abstract class BooleanValue {
	// done
}

//open class IntegerValue {
//	// done
//}
//
//open class Trace {
//	
//}
//
//open class Context {
//	
//}
//
//open class IntegerVariable {
//	
//}
//
//open class BooleanVariable {
//	
//}
//- Cannot find corresponding concept Trace
//- Cannot find corresponding concept IntegerValue
//- Cannot find corresponding concept Context
//- Duplicate open-class IntegerValue in activitydiagram_exec
//- Cannot find corresponding concept IntegerVariable
//- Cannot find corresponding concept BooleanVariable