behavior execad

import java.util.List
import activitydiagram.ActivityNode
import activitydiagram.Token
import activitydiagram.InputValue
import activitydiagram.InitialNode
import activitydiagram.BooleanValue
import activitydiagram.ControlFlow
import activitydiagram.IntegerValue
import activitydiagram.Value
import activitydiagram.Variable
import activitydiagram.ActivitydiagramFactory

import ecore "platform:/resource/org.modelexecution.operationalsemantics.ad.clean/model/activitydiagram.ecore"

open class Activity {
	def void main(List<InputValue> inputValues) {
		alg.$(self).initialize(inputValues)
		alg.$(self).run()
	}

	def void initialize(List<InputValue> inputValues) {
		// Initialize local variables
		self.locals.forEach[v | v.currentValue = v.initialValue]
		// Initialize input values
		inputValues?.forEach[v | v.variable.currentValue = v.value]
		// Initialize trace
		self.trace = ActivitydiagramFactory::eINSTANCE.createTrace
	}

	def void run() {
		// Run all nodes
		self.nodes.forEach[n | alg.$(n).run()]

		alg.$(self).fireInitialNode()
		
		var enabled = alg.$(self).getEnabledNodes()
		while (!enabled.empty) {
			alg.$(self).fireNode(enabled.head)
			enabled = alg.$(self).getEnabledNodes()
		}
	}

	def List<ActivityNode> getEnabledNodes() {
		return self.nodes.filter[n | alg.$(n).isReady()].toList
	}

	def void fireNode(ActivityNode node) {
		alg.$(node).fire(alg.$(node).takeOfferedTokens())
		self.trace.executedNodes += node
	}

	def void fireInitialNode() {
		alg.$(self).fireNode(alg.$(self).getInitialNode())
	}

	def InitialNode getInitialNode() {
		return self.nodes.filter(InitialNode).head
	}

	def void terminate() {
		self.nodes.forEach[n | alg.$(n).terminate()]
	}
}

open class ActivityNode {
	def void run() {
		self.running = true
	}

	def boolean isReady() {
		return self.running
	}

	def void sendOffers(List<Token> tokens) {
		self.outgoing.forEach[e | alg.$(e).sendOffer(tokens)]
	}

	def List<Token> takeOfferedTokens() {
		val allTokens = newArrayList
		self.incoming.forEach[edge |
			val tokens = alg.$(edge).takeOfferedTokens()
			tokens.forEach[t | alg.$(t).withdraw()]
			allTokens += tokens
		]
		return allTokens
	}

	def void addTokens(List<Token> tokens) {
		tokens.forEach[t |
			val transferred = alg.$(t).transfer(self)
			self.heldTokens += transferred
		]
	}

	def void removeToken(Token token) {
		self.heldTokens.remove(token)
	}

	def boolean hasOffers() {
		return self.incoming.forall[e | alg.$(e).hasOffer()]
	}

	def void terminate() {
		self.running = false
	}

	abstract def void fire(List<Token> tokens)
}

open class Action {
	abstract def void doAction()

	override boolean isReady() {
		return super.isReady() && alg.$(self).hasOffers()
	}

	def void sendOffers() {
		if (self.outgoing.size > 0) {
			val tokens = <Token>newArrayList(
				ActivitydiagramFactory::eINSTANCE.createControlToken
			)
			alg.$(self).addTokens(tokens)
			alg.$(self.outgoing.head).sendOffer(tokens)
		}
	}

	override void fire(List<Token> tokens) {
		alg.$(self).doAction()
		alg.$(self).sendOffers()
	}
}

open class OpaqueAction {
	override void doAction() {
		self.expressions.forEach[e | alg.$(e).execute()]
	}
}

open class ActivityEdge {
	def void sendOffer(List<Token> tokens) {
		val offer = ActivitydiagramFactory::eINSTANCE.createOffer
		tokens.forEach[token | offer.offeredTokens += token]
		self.offers += offer
	}

	def List<Token> takeOfferedTokens() {
		val tokens = <Token>newArrayList
		self.offers.forEach[o | tokens += o.offeredTokens]
		self.offers.clear
		return tokens
	}

	def boolean hasOffer() {
		return self.offers.exists[o | alg.$(o).hasTokens()]
	}
}

open class ActivityFinalNode {
	override void fire(List<Token> tokens) {
		alg.$(self.activity).terminate()
	}
}

open class DecisionNode {
	override void fire(List<Token> tokens) {
		val selected =
			self.outgoing
			.filter(ControlFlow)
			.filter[(guard.currentValue as BooleanValue).isValue]
			.head
		
		if (selected !== null) {
			alg.$(self).addTokens(tokens)
			alg.$(selected).sendOffer(tokens)
		}
	}

	override boolean isReady() {
		return self.incoming.forall[e | alg.$(e).hasOffer()]
	}
}

open class ForkNode {
	override void fire(List<Token> tokens) {
		val forkedTokens = <Token>newArrayList
		tokens.forEach[t |
			forkedTokens += ActivitydiagramFactory::eINSTANCE.createForkedToken => [
				baseToken = t
				remainingOffersCount = self.outgoing.size
			]
		]
		alg.$(self).addTokens(forkedTokens)
		alg.$(self).sendOffers(forkedTokens)
	}
}

open class ControlNode {
	override void fire(List<Token> tokens) {
		alg.$(self).addTokens(tokens)
		alg.$(self).sendOffers(tokens)
	}

	override boolean isReady() {
		return super.isReady() && alg.$(self).hasOffers()
	}
}

open class InitialNode {
	override void fire(List<Token> tokens) {
		val producedTokens = <Token>newArrayList(
			ActivitydiagramFactory::eINSTANCE.createControlToken
		)
		alg.$(self).addTokens(producedTokens)
		alg.$(self).sendOffers(producedTokens)
	}

	override boolean isReady() {
		return false
	}
}

open class JoinNode {
	override boolean isReady() {
		return self.incoming.forall[e | alg.$(e).hasOffer()]
	}
}

open class MergeNode {
	override boolean hasOffers() {
		return self.incoming.exists[e | alg.$(e).hasOffer()]
	}
}

open class Offer {
	def boolean hasTokens() {
		alg.$(self).removeWithdrawnTokens()
		return !self.offeredTokens.empty
	}

	def void removeWithdrawnTokens() {
		self.offeredTokens.removeIf[t | alg.$(t).isWithdrawn()]
	}
}

open class Token {
	def boolean isWithdrawn() {
		return self.holder === null
	}

	def void withdraw() {
		if (!isWithdrawn()) {
			alg.$(self.holder).removeToken(self)
			self.holder = null
		}
	}

	def Token transfer(ActivityNode holder) {
		if (self.holder !== null)
			alg.$(self).withdraw()
		self.holder = holder
		return self
	}
}

open class ForkedToken {
	override void withdraw() {
		if (!alg.$(self.baseToken).isWithdrawn())
			alg.$(self.baseToken).withdraw();
		if (self.remainingOffersCount > 0)
			self.remainingOffersCount = self.remainingOffersCount - 1
		if (self.remainingOffersCount == 0)
			super.withdraw()
	}
}

open class Expression {
	abstract def void execute()
}

open class BooleanExpression {
	def boolean getCurrentValue(Variable variable) {
		var boolean currentValue = false
		val value = variable.currentValue
		if (value instanceof BooleanValue)
			currentValue = value.isValue
		return currentValue
	}

	def void assignValue(boolean value) {
		self.assignee.currentValue =
			ActivitydiagramFactory::eINSTANCE.createBooleanValue => [bv |
				bv.value = value
			]
	}
}

open class IntegerExpression {
	def int getCurrentValue(Variable variable) {
		var int currentValue = 0
		val value = variable.currentValue
		if (value instanceof IntegerValue)
			currentValue = value.value
		return currentValue
	}
}

open class BooleanUnaryExpression {
	override void execute() {
		val opValue = alg.$(self).getCurrentValue(self.operand)

		switch (self.operator) {
			case NOT: alg.$(self).assignValue(!opValue)
		}
	}
}

open class BooleanBinaryExpression {
	override void execute() {
		val opVal1 = alg.$(self).getCurrentValue(self.operand1)
		val opVal2 = alg.$(self).getCurrentValue(self.operand2)
		val result =
			switch (self.operator) {
				case AND: opVal1 && opVal2
				case OR:  opVal1 || opVal2
			}
		alg.$(self).assignValue(result)
	}
}

open class IntegerComparisonExpression {
	override void execute() {
		val opVal1 = alg.$(self).getCurrentValue(self.operand1)
		val opVal2 = alg.$(self).getCurrentValue(self.operand2)
		val result =
			switch (self.operator) {
				case EQUALS:          opVal1 == opVal2
				case GREATER:         opVal1 > opVal2
				case GREATER_EQUALS:  opVal1 >= opVal2
				case SMALLER:         opVal1 < opVal2
				case SMALLER_EQUALS:  opVal1 <= opVal2
			}

		self.assignee.currentValue =
			ActivitydiagramFactory::eINSTANCE.createBooleanValue => [bv |
				bv.value = result
			]
	}
}

open class IntegerCalculationExpression {
	override void execute() {
		val opVal1 = alg.$(self).getCurrentValue(self.operand1)
		val opVal2 = alg.$(self).getCurrentValue(self.operand2)
		val result =
			switch (self.operator) {
				case ADD:     opVal1 + opVal2
				case SUBRACT: opVal1 - opVal2
			}

		self.assignee.currentValue =
			ActivitydiagramFactory::eINSTANCE.createIntegerValue => [iv |
				iv.value = result
			]
	}
}

open class Variable {
	abstract def Value getCurrentValue()
	abstract def void setCurrentValue(Value value)
}

open class BooleanVariable {
	override Value getCurrentValue() {
		return self.currentValue
	}

	override void setCurrentValue(Value value) {
		if (value instanceof BooleanValue)
			self.currentValue = value
	}
}

open class IntegerVariable {
	override Value getCurrentValue() {
		return self.currentValue
	}

	override void setCurrentValue(Value value) {
		if (value instanceof IntegerValue)
			self.currentValue = value
	}
}
