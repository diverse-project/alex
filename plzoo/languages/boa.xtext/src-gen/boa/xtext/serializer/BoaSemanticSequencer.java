/*
 * generated by Xtext 2.14.0
 */
package boa.xtext.serializer;

import boa.model.boa.App;
import boa.model.boa.ArithOpDivide;
import boa.model.boa.ArithOpMinus;
import boa.model.boa.ArithOpPlus;
import boa.model.boa.ArithOpRemainder;
import boa.model.boa.ArithOpTimes;
import boa.model.boa.Assign;
import boa.model.boa.BObject;
import boa.model.boa.BoaPackage;
import boa.model.boa.Bool;
import boa.model.boa.BoolOpAnd;
import boa.model.boa.BoolOpEqual;
import boa.model.boa.BoolOpLess;
import boa.model.boa.BoolOpNot;
import boa.model.boa.BoolOpOr;
import boa.model.boa.BoolOpUnequal;
import boa.model.boa.Copy;
import boa.model.boa.Def;
import boa.model.boa.Field;
import boa.model.boa.File;
import boa.model.boa.Fun;
import boa.model.boa.If;
import boa.model.boa.Int;
import boa.model.boa.Let;
import boa.model.boa.Project;
import boa.model.boa.Seq;
import boa.model.boa.Skip;
import boa.model.boa.This;
import boa.model.boa.Var;
import boa.model.boa.With;
import boa.xtext.services.BoaGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class BoaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BoaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BoaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BoaPackage.APP:
				sequence_App(context, (App) semanticObject); 
				return; 
			case BoaPackage.ARITH_OP_DIVIDE:
				sequence_ArithOpDivide(context, (ArithOpDivide) semanticObject); 
				return; 
			case BoaPackage.ARITH_OP_MINUS:
				sequence_ArithOpMinus(context, (ArithOpMinus) semanticObject); 
				return; 
			case BoaPackage.ARITH_OP_PLUS:
				sequence_ArithOpPlus(context, (ArithOpPlus) semanticObject); 
				return; 
			case BoaPackage.ARITH_OP_REMAINDER:
				sequence_ArithOpRemainder(context, (ArithOpRemainder) semanticObject); 
				return; 
			case BoaPackage.ARITH_OP_TIMES:
				sequence_ArithOpTimes(context, (ArithOpTimes) semanticObject); 
				return; 
			case BoaPackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case BoaPackage.BOBJECT:
				sequence_BObject(context, (BObject) semanticObject); 
				return; 
			case BoaPackage.BOOL:
				sequence_Bool(context, (Bool) semanticObject); 
				return; 
			case BoaPackage.BOOL_OP_AND:
				sequence_BoolOpAnd(context, (BoolOpAnd) semanticObject); 
				return; 
			case BoaPackage.BOOL_OP_EQUAL:
				sequence_BoolOpEqual(context, (BoolOpEqual) semanticObject); 
				return; 
			case BoaPackage.BOOL_OP_LESS:
				sequence_BoolOpLess(context, (BoolOpLess) semanticObject); 
				return; 
			case BoaPackage.BOOL_OP_NOT:
				sequence_BoolOpNot(context, (BoolOpNot) semanticObject); 
				return; 
			case BoaPackage.BOOL_OP_OR:
				sequence_BoolOpOr(context, (BoolOpOr) semanticObject); 
				return; 
			case BoaPackage.BOOL_OP_UNEQUAL:
				sequence_BoolOpUnequal(context, (BoolOpUnequal) semanticObject); 
				return; 
			case BoaPackage.COPY:
				sequence_Copy(context, (Copy) semanticObject); 
				return; 
			case BoaPackage.DEF:
				sequence_Def(context, (Def) semanticObject); 
				return; 
			case BoaPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case BoaPackage.FILE:
				sequence_File(context, (File) semanticObject); 
				return; 
			case BoaPackage.FUN:
				sequence_Fun(context, (Fun) semanticObject); 
				return; 
			case BoaPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case BoaPackage.INT:
				sequence_Intz(context, (Int) semanticObject); 
				return; 
			case BoaPackage.LET:
				sequence_Let(context, (Let) semanticObject); 
				return; 
			case BoaPackage.PROJECT:
				sequence_Project(context, (Project) semanticObject); 
				return; 
			case BoaPackage.SEQ:
				sequence_Seq(context, (Seq) semanticObject); 
				return; 
			case BoaPackage.SKIP:
				sequence_Skip(context, (Skip) semanticObject); 
				return; 
			case BoaPackage.THIS:
				sequence_This(context, (This) semanticObject); 
				return; 
			case BoaPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case BoaPackage.WITH:
				sequence_BWith(context, (With) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     TopLevelCmd returns App
	 *     Expr returns App
	 *     App returns App
	 *     NonApp returns App
	 *     ArithOpPlus returns App
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns App
	 *     ArithOpMinus returns App
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns App
	 *     ArithOpTimes returns App
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns App
	 *     ArithOpDivide returns App
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns App
	 *     ArithOpRemainder returns App
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns App
	 *     BoolOpLess returns App
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns App
	 *     BoolOpEqual returns App
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns App
	 *     BoolOpUnequal returns App
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns App
	 *     BoolOpAnd returns App
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns App
	 *     BoolOpOr returns App
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns App
	 *     BWith returns App
	 *     BWith.With_1_0_0_0 returns App
	 *     Assign returns App
	 *     Assign.Assign_1_0_0_0 returns App
	 *     Project returns App
	 *     Project.Project_1_0_0_0 returns App
	 *     Seq returns App
	 *     Seq.Seq_1_0_0_0 returns App
	 *     NonAppTerminal returns App
	 *     Parens returns App
	 *
	 * Constraint:
	 *     apps+=NonApp+
	 */
	protected void sequence_App(ISerializationContext context, App semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns ArithOpDivide
	 *     ArithOpPlus returns ArithOpDivide
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns ArithOpDivide
	 *     ArithOpMinus returns ArithOpDivide
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns ArithOpDivide
	 *     ArithOpTimes returns ArithOpDivide
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns ArithOpDivide
	 *     ArithOpDivide returns ArithOpDivide
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns ArithOpDivide
	 *
	 * Constraint:
	 *     (lhs=ArithOpDivide_ArithOpDivide_1_0_0_0 rhs=ArithOpRemainder)
	 */
	protected void sequence_ArithOpDivide(ISerializationContext context, ArithOpDivide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.ARITH_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.ARITH_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.ARITH_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.ARITH_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithOpDivideAccess().getArithOpDivideLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getArithOpDivideAccess().getRhsArithOpRemainderParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns ArithOpMinus
	 *     ArithOpPlus returns ArithOpMinus
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns ArithOpMinus
	 *     ArithOpMinus returns ArithOpMinus
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns ArithOpMinus
	 *
	 * Constraint:
	 *     (lhs=ArithOpMinus_ArithOpMinus_1_0_0_0 rhs=ArithOpTimes)
	 */
	protected void sequence_ArithOpMinus(ISerializationContext context, ArithOpMinus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.ARITH_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.ARITH_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.ARITH_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.ARITH_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithOpMinusAccess().getArithOpMinusLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getArithOpMinusAccess().getRhsArithOpTimesParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns ArithOpPlus
	 *     ArithOpPlus returns ArithOpPlus
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns ArithOpPlus
	 *
	 * Constraint:
	 *     (lhs=ArithOpPlus_ArithOpPlus_1_0_0_0 rhs=ArithOpMinus)
	 */
	protected void sequence_ArithOpPlus(ISerializationContext context, ArithOpPlus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.ARITH_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.ARITH_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.ARITH_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.ARITH_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithOpPlusAccess().getArithOpPlusLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getArithOpPlusAccess().getRhsArithOpMinusParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns ArithOpRemainder
	 *     ArithOpPlus returns ArithOpRemainder
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns ArithOpRemainder
	 *     ArithOpMinus returns ArithOpRemainder
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns ArithOpRemainder
	 *     ArithOpTimes returns ArithOpRemainder
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns ArithOpRemainder
	 *     ArithOpDivide returns ArithOpRemainder
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns ArithOpRemainder
	 *     ArithOpRemainder returns ArithOpRemainder
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns ArithOpRemainder
	 *
	 * Constraint:
	 *     (lhs=ArithOpRemainder_ArithOpRemainder_1_0_0_0 rhs=BoolOpLess)
	 */
	protected void sequence_ArithOpRemainder(ISerializationContext context, ArithOpRemainder semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.ARITH_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.ARITH_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.ARITH_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.ARITH_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithOpRemainderAccess().getArithOpRemainderLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getArithOpRemainderAccess().getRhsBoolOpLessParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns ArithOpTimes
	 *     ArithOpPlus returns ArithOpTimes
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns ArithOpTimes
	 *     ArithOpMinus returns ArithOpTimes
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns ArithOpTimes
	 *     ArithOpTimes returns ArithOpTimes
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns ArithOpTimes
	 *
	 * Constraint:
	 *     (lhs=ArithOpTimes_ArithOpTimes_1_0_0_0 rhs=ArithOpDivide)
	 */
	protected void sequence_ArithOpTimes(ISerializationContext context, ArithOpTimes semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.ARITH_OP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.ARITH_OP__LHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.ARITH_OP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.ARITH_OP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithOpTimesAccess().getArithOpTimesLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getArithOpTimesAccess().getRhsArithOpDivideParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns Assign
	 *     ArithOpPlus returns Assign
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns Assign
	 *     ArithOpMinus returns Assign
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns Assign
	 *     ArithOpTimes returns Assign
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns Assign
	 *     ArithOpDivide returns Assign
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns Assign
	 *     ArithOpRemainder returns Assign
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns Assign
	 *     BoolOpLess returns Assign
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns Assign
	 *     BoolOpEqual returns Assign
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns Assign
	 *     BoolOpUnequal returns Assign
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns Assign
	 *     BoolOpAnd returns Assign
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns Assign
	 *     BoolOpOr returns Assign
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns Assign
	 *     BWith returns Assign
	 *     BWith.With_1_0_0_0 returns Assign
	 *     Assign returns Assign
	 *
	 * Constraint:
	 *     (lhs=Assign_Assign_1_0_0_0 rhs=App)
	 */
	protected void sequence_Assign(ISerializationContext context, Assign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.ASSIGN__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.ASSIGN__LHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.ASSIGN__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.ASSIGN__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignAccess().getAssignLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAssignAccess().getRhsAppParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns BObject
	 *     ArithOpPlus returns BObject
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns BObject
	 *     ArithOpMinus returns BObject
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns BObject
	 *     ArithOpTimes returns BObject
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns BObject
	 *     ArithOpDivide returns BObject
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns BObject
	 *     ArithOpRemainder returns BObject
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns BObject
	 *     BoolOpLess returns BObject
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns BObject
	 *     BoolOpEqual returns BObject
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns BObject
	 *     BoolOpUnequal returns BObject
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns BObject
	 *     BoolOpAnd returns BObject
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns BObject
	 *     BoolOpOr returns BObject
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns BObject
	 *     BWith returns BObject
	 *     BWith.With_1_0_0_0 returns BObject
	 *     Assign returns BObject
	 *     Assign.Assign_1_0_0_0 returns BObject
	 *     Project returns BObject
	 *     Project.Project_1_0_0_0 returns BObject
	 *     Seq returns BObject
	 *     Seq.Seq_1_0_0_0 returns BObject
	 *     NonAppTerminal returns BObject
	 *     BObject returns BObject
	 *
	 * Constraint:
	 *     (fields+=Field fields+=Field*)?
	 */
	protected void sequence_BObject(ISerializationContext context, BObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns With
	 *     ArithOpPlus returns With
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns With
	 *     ArithOpMinus returns With
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns With
	 *     ArithOpTimes returns With
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns With
	 *     ArithOpDivide returns With
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns With
	 *     ArithOpRemainder returns With
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns With
	 *     BoolOpLess returns With
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns With
	 *     BoolOpEqual returns With
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns With
	 *     BoolOpUnequal returns With
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns With
	 *     BoolOpAnd returns With
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns With
	 *     BoolOpOr returns With
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns With
	 *     BWith returns With
	 *     BWith.With_1_0_0_0 returns With
	 *
	 * Constraint:
	 *     (lhs=BWith_With_1_0_0_0 rhs=Assign)
	 */
	protected void sequence_BWith(ISerializationContext context, With semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.WITH__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.WITH__LHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.WITH__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.WITH__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBWithAccess().getWithLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getBWithAccess().getRhsAssignParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns BoolOpAnd
	 *     ArithOpPlus returns BoolOpAnd
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns BoolOpAnd
	 *     ArithOpMinus returns BoolOpAnd
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns BoolOpAnd
	 *     ArithOpTimes returns BoolOpAnd
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns BoolOpAnd
	 *     ArithOpDivide returns BoolOpAnd
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns BoolOpAnd
	 *     ArithOpRemainder returns BoolOpAnd
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns BoolOpAnd
	 *     BoolOpLess returns BoolOpAnd
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns BoolOpAnd
	 *     BoolOpEqual returns BoolOpAnd
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns BoolOpAnd
	 *     BoolOpUnequal returns BoolOpAnd
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns BoolOpAnd
	 *     BoolOpAnd returns BoolOpAnd
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns BoolOpAnd
	 *
	 * Constraint:
	 *     (lhs=BoolOpAnd_BoolOpAnd_1_0_0_0 rhs=BoolOpOr)
	 */
	protected void sequence_BoolOpAnd(ISerializationContext context, BoolOpAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.BOOL_OP_AND__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.BOOL_OP_AND__LHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.BOOL_OP_AND__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.BOOL_OP_AND__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolOpAndAccess().getBoolOpAndLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getBoolOpAndAccess().getRhsBoolOpOrParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns BoolOpEqual
	 *     ArithOpPlus returns BoolOpEqual
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns BoolOpEqual
	 *     ArithOpMinus returns BoolOpEqual
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns BoolOpEqual
	 *     ArithOpTimes returns BoolOpEqual
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns BoolOpEqual
	 *     ArithOpDivide returns BoolOpEqual
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns BoolOpEqual
	 *     ArithOpRemainder returns BoolOpEqual
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns BoolOpEqual
	 *     BoolOpLess returns BoolOpEqual
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns BoolOpEqual
	 *     BoolOpEqual returns BoolOpEqual
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns BoolOpEqual
	 *
	 * Constraint:
	 *     (lhs=BoolOpEqual_BoolOpEqual_1_0_0_0 rhs=BoolOpUnequal)
	 */
	protected void sequence_BoolOpEqual(ISerializationContext context, BoolOpEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.BOOL_OP_EQUAL__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.BOOL_OP_EQUAL__LHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.BOOL_OP_EQUAL__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.BOOL_OP_EQUAL__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolOpEqualAccess().getBoolOpEqualLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getBoolOpEqualAccess().getRhsBoolOpUnequalParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns BoolOpLess
	 *     ArithOpPlus returns BoolOpLess
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns BoolOpLess
	 *     ArithOpMinus returns BoolOpLess
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns BoolOpLess
	 *     ArithOpTimes returns BoolOpLess
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns BoolOpLess
	 *     ArithOpDivide returns BoolOpLess
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns BoolOpLess
	 *     ArithOpRemainder returns BoolOpLess
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns BoolOpLess
	 *     BoolOpLess returns BoolOpLess
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns BoolOpLess
	 *
	 * Constraint:
	 *     (lhs=BoolOpLess_BoolOpLess_1_0_0_0 rhs=BoolOpEqual)
	 */
	protected void sequence_BoolOpLess(ISerializationContext context, BoolOpLess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.BOOL_OP_LESS__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.BOOL_OP_LESS__LHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.BOOL_OP_LESS__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.BOOL_OP_LESS__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolOpLessAccess().getBoolOpLessLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getBoolOpLessAccess().getRhsBoolOpEqualParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns BoolOpNot
	 *     ArithOpPlus returns BoolOpNot
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns BoolOpNot
	 *     ArithOpMinus returns BoolOpNot
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns BoolOpNot
	 *     ArithOpTimes returns BoolOpNot
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns BoolOpNot
	 *     ArithOpDivide returns BoolOpNot
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns BoolOpNot
	 *     ArithOpRemainder returns BoolOpNot
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns BoolOpNot
	 *     BoolOpLess returns BoolOpNot
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns BoolOpNot
	 *     BoolOpEqual returns BoolOpNot
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns BoolOpNot
	 *     BoolOpUnequal returns BoolOpNot
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns BoolOpNot
	 *     BoolOpAnd returns BoolOpNot
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns BoolOpNot
	 *     BoolOpOr returns BoolOpNot
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns BoolOpNot
	 *     BWith returns BoolOpNot
	 *     BWith.With_1_0_0_0 returns BoolOpNot
	 *     Assign returns BoolOpNot
	 *     Assign.Assign_1_0_0_0 returns BoolOpNot
	 *     Project returns BoolOpNot
	 *     Project.Project_1_0_0_0 returns BoolOpNot
	 *     Seq returns BoolOpNot
	 *     Seq.Seq_1_0_0_0 returns BoolOpNot
	 *     NonAppTerminal returns BoolOpNot
	 *     BoolOpNot returns BoolOpNot
	 *
	 * Constraint:
	 *     expr=App
	 */
	protected void sequence_BoolOpNot(ISerializationContext context, BoolOpNot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.BOOL_OP_NOT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.BOOL_OP_NOT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolOpNotAccess().getExprAppParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns BoolOpOr
	 *     ArithOpPlus returns BoolOpOr
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns BoolOpOr
	 *     ArithOpMinus returns BoolOpOr
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns BoolOpOr
	 *     ArithOpTimes returns BoolOpOr
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns BoolOpOr
	 *     ArithOpDivide returns BoolOpOr
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns BoolOpOr
	 *     ArithOpRemainder returns BoolOpOr
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns BoolOpOr
	 *     BoolOpLess returns BoolOpOr
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns BoolOpOr
	 *     BoolOpEqual returns BoolOpOr
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns BoolOpOr
	 *     BoolOpUnequal returns BoolOpOr
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns BoolOpOr
	 *     BoolOpAnd returns BoolOpOr
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns BoolOpOr
	 *     BoolOpOr returns BoolOpOr
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns BoolOpOr
	 *
	 * Constraint:
	 *     (lhs=BoolOpOr_BoolOpOr_1_0_0_0 rhs=BWith)
	 */
	protected void sequence_BoolOpOr(ISerializationContext context, BoolOpOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.BOOL_OP_OR__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.BOOL_OP_OR__LHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.BOOL_OP_OR__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.BOOL_OP_OR__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolOpOrAccess().getBoolOpOrLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getBoolOpOrAccess().getRhsBWithParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns BoolOpUnequal
	 *     ArithOpPlus returns BoolOpUnequal
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns BoolOpUnequal
	 *     ArithOpMinus returns BoolOpUnequal
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns BoolOpUnequal
	 *     ArithOpTimes returns BoolOpUnequal
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns BoolOpUnequal
	 *     ArithOpDivide returns BoolOpUnequal
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns BoolOpUnequal
	 *     ArithOpRemainder returns BoolOpUnequal
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns BoolOpUnequal
	 *     BoolOpLess returns BoolOpUnequal
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns BoolOpUnequal
	 *     BoolOpEqual returns BoolOpUnequal
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns BoolOpUnequal
	 *     BoolOpUnequal returns BoolOpUnequal
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns BoolOpUnequal
	 *
	 * Constraint:
	 *     (lhs=BoolOpUnequal_BoolOpUnequal_1_0_0_0 rhs=BoolOpAnd)
	 */
	protected void sequence_BoolOpUnequal(ISerializationContext context, BoolOpUnequal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.BOOL_OP_UNEQUAL__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.BOOL_OP_UNEQUAL__LHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.BOOL_OP_UNEQUAL__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.BOOL_OP_UNEQUAL__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolOpUnequalAccess().getBoolOpUnequalLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getBoolOpUnequalAccess().getRhsBoolOpAndParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns Bool
	 *     ArithOpPlus returns Bool
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns Bool
	 *     ArithOpMinus returns Bool
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns Bool
	 *     ArithOpTimes returns Bool
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns Bool
	 *     ArithOpDivide returns Bool
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns Bool
	 *     ArithOpRemainder returns Bool
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns Bool
	 *     BoolOpLess returns Bool
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns Bool
	 *     BoolOpEqual returns Bool
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns Bool
	 *     BoolOpUnequal returns Bool
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns Bool
	 *     BoolOpAnd returns Bool
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns Bool
	 *     BoolOpOr returns Bool
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns Bool
	 *     BWith returns Bool
	 *     BWith.With_1_0_0_0 returns Bool
	 *     Assign returns Bool
	 *     Assign.Assign_1_0_0_0 returns Bool
	 *     Project returns Bool
	 *     Project.Project_1_0_0_0 returns Bool
	 *     Seq returns Bool
	 *     Seq.Seq_1_0_0_0 returns Bool
	 *     NonAppTerminal returns Bool
	 *     Bool returns Bool
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_Bool(ISerializationContext context, Bool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns Copy
	 *     ArithOpPlus returns Copy
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns Copy
	 *     ArithOpMinus returns Copy
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns Copy
	 *     ArithOpTimes returns Copy
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns Copy
	 *     ArithOpDivide returns Copy
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns Copy
	 *     ArithOpRemainder returns Copy
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns Copy
	 *     BoolOpLess returns Copy
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns Copy
	 *     BoolOpEqual returns Copy
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns Copy
	 *     BoolOpUnequal returns Copy
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns Copy
	 *     BoolOpAnd returns Copy
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns Copy
	 *     BoolOpOr returns Copy
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns Copy
	 *     BWith returns Copy
	 *     BWith.With_1_0_0_0 returns Copy
	 *     Assign returns Copy
	 *     Assign.Assign_1_0_0_0 returns Copy
	 *     Project returns Copy
	 *     Project.Project_1_0_0_0 returns Copy
	 *     Seq returns Copy
	 *     Seq.Seq_1_0_0_0 returns Copy
	 *     NonAppTerminal returns Copy
	 *     Copy returns Copy
	 *
	 * Constraint:
	 *     copy=App
	 */
	protected void sequence_Copy(ISerializationContext context, Copy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.COPY__COPY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.COPY__COPY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCopyAccess().getCopyAppParserRuleCall_2_0(), semanticObject.getCopy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelCmd returns Def
	 *     Def returns Def
	 *
	 * Constraint:
	 *     (name=ID expr=Expr)
	 */
	protected void sequence_Def(ISerializationContext context, Def semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.DEF__NAME));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.DEF__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.DEF__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDefAccess().getExprExprParserRuleCall_4_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (name=ID value=Expr)
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.FIELD__NAME));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.FIELD__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.FIELD__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldAccess().getValueExprParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     File returns File
	 *
	 * Constraint:
	 *     (commands+=TopLevelCmd commands+=TopLevelCmd*)?
	 */
	protected void sequence_File(ISerializationContext context, File semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns Fun
	 *     ArithOpPlus returns Fun
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns Fun
	 *     ArithOpMinus returns Fun
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns Fun
	 *     ArithOpTimes returns Fun
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns Fun
	 *     ArithOpDivide returns Fun
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns Fun
	 *     ArithOpRemainder returns Fun
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns Fun
	 *     BoolOpLess returns Fun
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns Fun
	 *     BoolOpEqual returns Fun
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns Fun
	 *     BoolOpUnequal returns Fun
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns Fun
	 *     BoolOpAnd returns Fun
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns Fun
	 *     BoolOpOr returns Fun
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns Fun
	 *     BWith returns Fun
	 *     BWith.With_1_0_0_0 returns Fun
	 *     Assign returns Fun
	 *     Assign.Assign_1_0_0_0 returns Fun
	 *     Project returns Fun
	 *     Project.Project_1_0_0_0 returns Fun
	 *     Seq returns Fun
	 *     Seq.Seq_1_0_0_0 returns Fun
	 *     NonAppTerminal returns Fun
	 *     Fun returns Fun
	 *
	 * Constraint:
	 *     (name=ID body=App)
	 */
	protected void sequence_Fun(ISerializationContext context, Fun semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.FUN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.FUN__NAME));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.FUN__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.FUN__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFunAccess().getBodyAppParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns If
	 *     ArithOpPlus returns If
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns If
	 *     ArithOpMinus returns If
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns If
	 *     ArithOpTimes returns If
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns If
	 *     ArithOpDivide returns If
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns If
	 *     ArithOpRemainder returns If
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns If
	 *     BoolOpLess returns If
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns If
	 *     BoolOpEqual returns If
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns If
	 *     BoolOpUnequal returns If
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns If
	 *     BoolOpAnd returns If
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns If
	 *     BoolOpOr returns If
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns If
	 *     BWith returns If
	 *     BWith.With_1_0_0_0 returns If
	 *     Assign returns If
	 *     Assign.Assign_1_0_0_0 returns If
	 *     Project returns If
	 *     Project.Project_1_0_0_0 returns If
	 *     Seq returns If
	 *     Seq.Seq_1_0_0_0 returns If
	 *     NonAppTerminal returns If
	 *     If returns If
	 *
	 * Constraint:
	 *     (cond=App then=App else=App)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.IF__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.IF__COND));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.IF__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.IF__THEN));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.IF__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.IF__ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfAccess().getCondAppParserRuleCall_2_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getIfAccess().getThenAppParserRuleCall_3_1_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getIfAccess().getElseAppParserRuleCall_3_2_1_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns Int
	 *     ArithOpPlus returns Int
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns Int
	 *     ArithOpMinus returns Int
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns Int
	 *     ArithOpTimes returns Int
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns Int
	 *     ArithOpDivide returns Int
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns Int
	 *     ArithOpRemainder returns Int
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns Int
	 *     BoolOpLess returns Int
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns Int
	 *     BoolOpEqual returns Int
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns Int
	 *     BoolOpUnequal returns Int
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns Int
	 *     BoolOpAnd returns Int
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns Int
	 *     BoolOpOr returns Int
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns Int
	 *     BWith returns Int
	 *     BWith.With_1_0_0_0 returns Int
	 *     Assign returns Int
	 *     Assign.Assign_1_0_0_0 returns Int
	 *     Project returns Int
	 *     Project.Project_1_0_0_0 returns Int
	 *     Seq returns Int
	 *     Seq.Seq_1_0_0_0 returns Int
	 *     NonAppTerminal returns Int
	 *     Intz returns Int
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Intz(ISerializationContext context, Int semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntzAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns Let
	 *     ArithOpPlus returns Let
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns Let
	 *     ArithOpMinus returns Let
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns Let
	 *     ArithOpTimes returns Let
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns Let
	 *     ArithOpDivide returns Let
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns Let
	 *     ArithOpRemainder returns Let
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns Let
	 *     BoolOpLess returns Let
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns Let
	 *     BoolOpEqual returns Let
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns Let
	 *     BoolOpUnequal returns Let
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns Let
	 *     BoolOpAnd returns Let
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns Let
	 *     BoolOpOr returns Let
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns Let
	 *     BWith returns Let
	 *     BWith.With_1_0_0_0 returns Let
	 *     Assign returns Let
	 *     Assign.Assign_1_0_0_0 returns Let
	 *     Project returns Let
	 *     Project.Project_1_0_0_0 returns Let
	 *     Seq returns Let
	 *     Seq.Seq_1_0_0_0 returns Let
	 *     NonAppTerminal returns Let
	 *     Let returns Let
	 *
	 * Constraint:
	 *     (name=ID lhs=App rhs=App)
	 */
	protected void sequence_Let(ISerializationContext context, Let semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.LET__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.LET__NAME));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.LET__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.LET__LHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.LET__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.LET__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLetAccess().getLhsAppParserRuleCall_4_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getLetAccess().getRhsAppParserRuleCall_5_0_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns Project
	 *     ArithOpPlus returns Project
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns Project
	 *     ArithOpMinus returns Project
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns Project
	 *     ArithOpTimes returns Project
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns Project
	 *     ArithOpDivide returns Project
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns Project
	 *     ArithOpRemainder returns Project
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns Project
	 *     BoolOpLess returns Project
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns Project
	 *     BoolOpEqual returns Project
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns Project
	 *     BoolOpUnequal returns Project
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns Project
	 *     BoolOpAnd returns Project
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns Project
	 *     BoolOpOr returns Project
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns Project
	 *     BWith returns Project
	 *     BWith.With_1_0_0_0 returns Project
	 *     Assign returns Project
	 *     Assign.Assign_1_0_0_0 returns Project
	 *     Project returns Project
	 *     Project.Project_1_0_0_0 returns Project
	 *
	 * Constraint:
	 *     (project=Project_Project_1_0_0_0 name=ID)
	 */
	protected void sequence_Project(ISerializationContext context, Project semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.PROJECT__PROJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.PROJECT__PROJECT));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.PROJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.PROJECT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProjectAccess().getProjectProjectAction_1_0_0_0(), semanticObject.getProject());
		feeder.accept(grammarAccess.getProjectAccess().getNameIDTerminalRuleCall_1_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns Seq
	 *     ArithOpPlus returns Seq
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns Seq
	 *     ArithOpMinus returns Seq
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns Seq
	 *     ArithOpTimes returns Seq
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns Seq
	 *     ArithOpDivide returns Seq
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns Seq
	 *     ArithOpRemainder returns Seq
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns Seq
	 *     BoolOpLess returns Seq
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns Seq
	 *     BoolOpEqual returns Seq
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns Seq
	 *     BoolOpUnequal returns Seq
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns Seq
	 *     BoolOpAnd returns Seq
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns Seq
	 *     BoolOpOr returns Seq
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns Seq
	 *     BWith returns Seq
	 *     BWith.With_1_0_0_0 returns Seq
	 *     Assign returns Seq
	 *     Assign.Assign_1_0_0_0 returns Seq
	 *     Project returns Seq
	 *     Project.Project_1_0_0_0 returns Seq
	 *     Seq returns Seq
	 *     Seq.Seq_1_0_0_0 returns Seq
	 *
	 * Constraint:
	 *     (rhs=Seq_Seq_1_0_0_0 lhs=NonAppTerminal)
	 */
	protected void sequence_Seq(ISerializationContext context, Seq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.SEQ__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.SEQ__RHS));
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.SEQ__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.SEQ__LHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSeqAccess().getSeqRhsAction_1_0_0_0(), semanticObject.getRhs());
		feeder.accept(grammarAccess.getSeqAccess().getLhsNonAppTerminalParserRuleCall_1_1_0(), semanticObject.getLhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns Skip
	 *     ArithOpPlus returns Skip
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns Skip
	 *     ArithOpMinus returns Skip
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns Skip
	 *     ArithOpTimes returns Skip
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns Skip
	 *     ArithOpDivide returns Skip
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns Skip
	 *     ArithOpRemainder returns Skip
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns Skip
	 *     BoolOpLess returns Skip
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns Skip
	 *     BoolOpEqual returns Skip
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns Skip
	 *     BoolOpUnequal returns Skip
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns Skip
	 *     BoolOpAnd returns Skip
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns Skip
	 *     BoolOpOr returns Skip
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns Skip
	 *     BWith returns Skip
	 *     BWith.With_1_0_0_0 returns Skip
	 *     Assign returns Skip
	 *     Assign.Assign_1_0_0_0 returns Skip
	 *     Project returns Skip
	 *     Project.Project_1_0_0_0 returns Skip
	 *     Seq returns Skip
	 *     Seq.Seq_1_0_0_0 returns Skip
	 *     NonAppTerminal returns Skip
	 *     Skip returns Skip
	 *
	 * Constraint:
	 *     {Skip}
	 */
	protected void sequence_Skip(ISerializationContext context, Skip semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns This
	 *     ArithOpPlus returns This
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns This
	 *     ArithOpMinus returns This
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns This
	 *     ArithOpTimes returns This
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns This
	 *     ArithOpDivide returns This
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns This
	 *     ArithOpRemainder returns This
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns This
	 *     BoolOpLess returns This
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns This
	 *     BoolOpEqual returns This
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns This
	 *     BoolOpUnequal returns This
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns This
	 *     BoolOpAnd returns This
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns This
	 *     BoolOpOr returns This
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns This
	 *     BWith returns This
	 *     BWith.With_1_0_0_0 returns This
	 *     Assign returns This
	 *     Assign.Assign_1_0_0_0 returns This
	 *     Project returns This
	 *     Project.Project_1_0_0_0 returns This
	 *     Seq returns This
	 *     Seq.Seq_1_0_0_0 returns This
	 *     NonAppTerminal returns This
	 *     This returns This
	 *
	 * Constraint:
	 *     {This}
	 */
	protected void sequence_This(ISerializationContext context, This semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NonApp returns Var
	 *     ArithOpPlus returns Var
	 *     ArithOpPlus.ArithOpPlus_1_0_0_0 returns Var
	 *     ArithOpMinus returns Var
	 *     ArithOpMinus.ArithOpMinus_1_0_0_0 returns Var
	 *     ArithOpTimes returns Var
	 *     ArithOpTimes.ArithOpTimes_1_0_0_0 returns Var
	 *     ArithOpDivide returns Var
	 *     ArithOpDivide.ArithOpDivide_1_0_0_0 returns Var
	 *     ArithOpRemainder returns Var
	 *     ArithOpRemainder.ArithOpRemainder_1_0_0_0 returns Var
	 *     BoolOpLess returns Var
	 *     BoolOpLess.BoolOpLess_1_0_0_0 returns Var
	 *     BoolOpEqual returns Var
	 *     BoolOpEqual.BoolOpEqual_1_0_0_0 returns Var
	 *     BoolOpUnequal returns Var
	 *     BoolOpUnequal.BoolOpUnequal_1_0_0_0 returns Var
	 *     BoolOpAnd returns Var
	 *     BoolOpAnd.BoolOpAnd_1_0_0_0 returns Var
	 *     BoolOpOr returns Var
	 *     BoolOpOr.BoolOpOr_1_0_0_0 returns Var
	 *     BWith returns Var
	 *     BWith.With_1_0_0_0 returns Var
	 *     Assign returns Var
	 *     Assign.Assign_1_0_0_0 returns Var
	 *     Project returns Var
	 *     Project.Project_1_0_0_0 returns Var
	 *     Seq returns Var
	 *     Seq.Seq_1_0_0_0 returns Var
	 *     NonAppTerminal returns Var
	 *     Var returns Var
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoaPackage.Literals.VAR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoaPackage.Literals.VAR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
