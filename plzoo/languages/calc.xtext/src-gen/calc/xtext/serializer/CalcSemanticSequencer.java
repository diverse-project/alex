/*
 * generated by Xtext 2.14.0
 */
package calc.xtext.serializer;

import calc.calc.CalcPackage;
import calc.calc.Divide;
import calc.calc.Minus;
import calc.calc.Negate;
import calc.calc.Numeral;
import calc.calc.Plus;
import calc.calc.Times;
import calc.xtext.services.CalcGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CalcSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CalcGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CalcPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CalcPackage.DIVIDE:
				sequence_Divide(context, (Divide) semanticObject); 
				return; 
			case CalcPackage.MINUS:
				sequence_Minus(context, (Minus) semanticObject); 
				return; 
			case CalcPackage.NEGATE:
				sequence_Terminals(context, (Negate) semanticObject); 
				return; 
			case CalcPackage.NUMERAL:
				sequence_Numeral(context, (Numeral) semanticObject); 
				return; 
			case CalcPackage.PLUS:
				sequence_Plus(context, (Plus) semanticObject); 
				return; 
			case CalcPackage.TIMES:
				sequence_Times(context, (Times) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Start returns Divide
	 *     Expression returns Divide
	 *     Minus returns Divide
	 *     Minus.Minus_1_0_0_0 returns Divide
	 *     Plus returns Divide
	 *     Plus.Plus_1_0_0_0 returns Divide
	 *     Divide returns Divide
	 *     Divide.Divide_1_0_0_0 returns Divide
	 *     Times returns Divide
	 *     Times.Times_1_0_0_0 returns Divide
	 *     Terminals returns Divide
	 *
	 * Constraint:
	 *     (lhs=Divide_Divide_1_0_0_0 rhs=Times)
	 */
	protected void sequence_Divide(ISerializationContext context, Divide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalcPackage.Literals.DIVIDE__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalcPackage.Literals.DIVIDE__LHS));
			if (transientValues.isValueTransient(semanticObject, CalcPackage.Literals.DIVIDE__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalcPackage.Literals.DIVIDE__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivideAccess().getDivideLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getDivideAccess().getRhsTimesParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Start returns Minus
	 *     Expression returns Minus
	 *     Minus returns Minus
	 *     Minus.Minus_1_0_0_0 returns Minus
	 *     Plus returns Minus
	 *     Plus.Plus_1_0_0_0 returns Minus
	 *     Divide returns Minus
	 *     Divide.Divide_1_0_0_0 returns Minus
	 *     Times returns Minus
	 *     Times.Times_1_0_0_0 returns Minus
	 *     Terminals returns Minus
	 *
	 * Constraint:
	 *     (lhs=Minus_Minus_1_0_0_0 rhs=Plus)
	 */
	protected void sequence_Minus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalcPackage.Literals.MINUS__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalcPackage.Literals.MINUS__LHS));
			if (transientValues.isValueTransient(semanticObject, CalcPackage.Literals.MINUS__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalcPackage.Literals.MINUS__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinusAccess().getMinusLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getMinusAccess().getRhsPlusParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Start returns Numeral
	 *     Expression returns Numeral
	 *     Minus returns Numeral
	 *     Minus.Minus_1_0_0_0 returns Numeral
	 *     Plus returns Numeral
	 *     Plus.Plus_1_0_0_0 returns Numeral
	 *     Divide returns Numeral
	 *     Divide.Divide_1_0_0_0 returns Numeral
	 *     Times returns Numeral
	 *     Times.Times_1_0_0_0 returns Numeral
	 *     Terminals returns Numeral
	 *     Numeral returns Numeral
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_Numeral(ISerializationContext context, Numeral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalcPackage.Literals.NUMERAL__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalcPackage.Literals.NUMERAL__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumeralAccess().getNINTTerminalRuleCall_1_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Start returns Plus
	 *     Expression returns Plus
	 *     Minus returns Plus
	 *     Minus.Minus_1_0_0_0 returns Plus
	 *     Plus returns Plus
	 *     Plus.Plus_1_0_0_0 returns Plus
	 *     Divide returns Plus
	 *     Divide.Divide_1_0_0_0 returns Plus
	 *     Times returns Plus
	 *     Times.Times_1_0_0_0 returns Plus
	 *     Terminals returns Plus
	 *
	 * Constraint:
	 *     (lhs=Plus_Plus_1_0_0_0 rhs=Divide)
	 */
	protected void sequence_Plus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalcPackage.Literals.PLUS__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalcPackage.Literals.PLUS__LHS));
			if (transientValues.isValueTransient(semanticObject, CalcPackage.Literals.PLUS__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalcPackage.Literals.PLUS__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusAccess().getPlusLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getPlusAccess().getRhsDivideParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Start returns Negate
	 *     Expression returns Negate
	 *     Minus returns Negate
	 *     Minus.Minus_1_0_0_0 returns Negate
	 *     Plus returns Negate
	 *     Plus.Plus_1_0_0_0 returns Negate
	 *     Divide returns Negate
	 *     Divide.Divide_1_0_0_0 returns Negate
	 *     Times returns Negate
	 *     Times.Times_1_0_0_0 returns Negate
	 *     Terminals returns Negate
	 *
	 * Constraint:
	 *     v=Expression
	 */
	protected void sequence_Terminals(ISerializationContext context, Negate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalcPackage.Literals.NEGATE__V) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalcPackage.Literals.NEGATE__V));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalsAccess().getVExpressionParserRuleCall_1_2_0(), semanticObject.getV());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Start returns Times
	 *     Expression returns Times
	 *     Minus returns Times
	 *     Minus.Minus_1_0_0_0 returns Times
	 *     Plus returns Times
	 *     Plus.Plus_1_0_0_0 returns Times
	 *     Divide returns Times
	 *     Divide.Divide_1_0_0_0 returns Times
	 *     Times returns Times
	 *     Times.Times_1_0_0_0 returns Times
	 *     Terminals returns Times
	 *
	 * Constraint:
	 *     (lhs=Times_Times_1_0_0_0 rhs=Terminals)
	 */
	protected void sequence_Times(ISerializationContext context, Times semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalcPackage.Literals.TIMES__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalcPackage.Literals.TIMES__LHS));
			if (transientValues.isValueTransient(semanticObject, CalcPackage.Literals.TIMES__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalcPackage.Literals.TIMES__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimesAccess().getTimesLhsAction_1_0_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getTimesAccess().getRhsTerminalsParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
}
