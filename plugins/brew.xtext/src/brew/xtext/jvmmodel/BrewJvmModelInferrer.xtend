/*
 * generated by Xtext 2.12.0
 */
package brew.xtext.jvmmodel

import ale.xtext.ale.AleClass
import ale.xtext.ale.AleFactory
import ale.xtext.ale.AleRoot
import ale.xtext.jvmmodel.AleJvmModelInferrer.ResolvedClass
import ale.xtext.utils.AleUtils
import ale.xtext.utils.EcoreUtils
import brew.xtext.brew.BrewRoot
import brew.xtext.util.NamingUtils
import com.google.inject.Inject
import java.util.List
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.resource.impl.ResourceImpl
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmTypeReference
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class BrewJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder
	@Inject extension NamingUtils
	@Inject extension EcoreUtils
	@Inject extension AleUtils

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the lambda you pass as the last argument.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch void infer(BrewRoot brewRoot, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		val projectName = brewRoot.eResource.URI.segment(1)
		val String ecorePath = '''/«projectName»/model/«brewRoot.name».ecore'''
		val String genModelPath = '''/«projectName»/model/«brewRoot.name».genmodel'''
		val EPackage pkg = ecorePath.loadEPackage
		val gm = genModelPath.loadCorrespondingGenmodel

		val virtualAleRoot = AleFactory.eINSTANCE.createAleRoot => [
			name = brewRoot.name
			ecoreImport = AleFactory.eINSTANCE.createEcoreImport => [
				uri = ecorePath
			]
			aleImports += brewRoot.importSemantics.map [ brewImport |
				AleFactory.eINSTANCE.createAleImport => [
					ref = brewImport.ale
				]
			]

		]

		val r = new ResourceImpl

		r.contents.add(virtualAleRoot)

		val List<EClass> allClasses = pkg.allClasses

		println('''AllClasses size «allClasses.length»''')
		val resolved = allClasses.sortBy[name].map [ eCls |
			val allCls = brewRoot.importSemantics.map[it.ale.classes].flatten
			val existingAleClass = allCls.findFirst [
				it.name == eCls.name
			]

			val aleCls = if (existingAleClass !== null)
					existingAleClass
				else {
					eCls.createAleClassFromBrew(virtualAleRoot, brewRoot)
				}
//			val genCls = if(eCls !== null) eCls.getGenClass(gm)
			val genCls = null
			new ResolvedClass(aleCls, eCls, genCls)
		].toList

		println('''Resolved size «resolved.size»''')

		brewRoot.brewRoot(pkg, acceptor, resolved)
		resolved.filter[aleCls.generated].forEach [
			inferOperationInterface(acceptor, virtualAleRoot)

		// Don't infer implementation for @Required classes
//				if (!eCls.hasRequiredAnnotation)
//					inferOperationImplementation(acceptor)
		]
	}

	def AleClass createAleClassFromBrew(EClass eCls, AleRoot virtualAleRoot, BrewRoot brewRoot) {
		// unicity control
		if (!virtualAleRoot.classes.exists[it.name == eCls.name]) {
			AleFactory.eINSTANCE.createAleClass => [
				// TODO: for new we create virtual ale class for the bound class
				name = eCls.name
				val relatedBind = brewRoot.bound.findFirst [
					it.requiredCls.name == eCls.name.substring(0, eCls.name.length - 4)
				]

				methods += relatedBind.requiredCls.methods.map [ clonedMethod |
					AleFactory.eINSTANCE.createOverrideMethod => [
						name = clonedMethod.name
						params += EcoreUtil2.copyAll(clonedMethod.params)
						type = EcoreUtil2.copy(clonedMethod.type)
					]
				]
				virtualAleRoot.classes += it
			]

		} else {
			virtualAleRoot.classes.findFirst[it.name == eCls.name]
		}
	}

	private def void inferOperationInterface(ResolvedClass r, IJvmDeclaredTypeAcceptor acceptor, AleRoot root) {
		acceptor.accept(r.aleCls.toClass(r.aleCls.operationInterfaceFqn)) [
			interface = true
			val eCls = r.eCls
			val allAleClasses = eCls.getAllAleClasses(root)
			superTypes += allAleClasses.filter[it != r.aleCls && generated].map [
				operationInterfaceFqn.typeRef
			]

			members += r.aleCls.methods.map [ m |
				m.toMethod(m.name, m.type) [
					abstract = true
					parameters += m.params.map[cloneWithProxies]
				]
			]
		]
	}

	def brewRoot(BrewRoot brewRoot, EPackage pkg, IJvmDeclaredTypeAcceptor acceptor, List<ResolvedClass> resolved) {
		acceptor.accept(brewRoot.toClass(brewRoot.getRevisitorInterfaceFqn)) [
			interface = true
			val bond = resolved.map [
				aleCls.toOperationInterfaceType
			]
			superTypes += pkg.revisitorInterfaceFqn.typeRef(bond)
		]
	}

	private def JvmTypeReference toOperationInterfaceType(AleClass aleCls) {
		return if (aleCls.generated)
			aleCls.operationInterfaceFqn.typeRef
		else if (aleCls.findNearestGeneratedParent !== null)
			aleCls.findNearestGeneratedParent.operationInterfaceFqn.typeRef
		else
			Object.typeRef
	}

}
