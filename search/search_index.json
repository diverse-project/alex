{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Alex is a language that provides a modular approach for defining external visitor-like semantics on top of ecore based abstract syntax. Main Features Java-like language; Seamlessly integrated with the eclipse ecosystem.","title":"Alex Language"},{"location":"#overview","text":"Alex is a language that provides a modular approach for defining external visitor-like semantics on top of ecore based abstract syntax.","title":"Overview"},{"location":"#main-features","text":"Java-like language; Seamlessly integrated with the eclipse ecosystem.","title":"Main Features"},{"location":"getting-started/","text":"Introduction This page introduces the main concepts of Alex by following the development of a small expression language. For more details about the language see TODO. TEL0 Tiny Expression Language 0 (TEL0) is a toy expression language with two concepts: Integer Literal (e.g. 0, 1...) Sum operation (e.g. +) Abstract Syntax We define the abstract syntax using ecore. This tutorial explains in details how to use ecore to define a metamodel. In order to understand the rest of this introduction, you only need to understand that ecore is a formalism to define metamodels and allows the generation of Java code that conforms to this definition. From the definition of TEL0, we define the following ecore model: We introduce the Exp abstract class in order to allow the recursive definition of sums (e.g. 1 + 2 + 3 + 4). From this metamodel definition we generate, using EMF, a set of java classes. Revisitor In addition to the set of java class, Alex offers the generation of a abstract, visitor-like, interface called a Revisitor . To understand this tutorial, and to use Alex, it is not required to understand the Revisitor mechanism. Just know that it's generation is required in order to be able to define a semantics on top of the abstract syntax. The interested reader can consult the revisitor page to understand the internal details. Semantics Once we have defined the abstract syntax of our language, we want to give it some meaning. The good news is, using Alex it is easy to define multiple meanings to a single abstract syntax in a modular way. We will show how to add a pretty printer and an evaluation semantics for TEL0. A pretty printer The pretty printer is a simple way to transform the object graph of an instance of the abstract syntax to a user readable string. For instance Add (LitVal(1), Add(LitVal(2), LitVal(3))) will be pretty printed to \"1 + 2 + 3\". The following Alex program is the definition of the pretty print semantics for TEL0. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 behavior prettyprint import ecore platform:/resource/tel0.model/model/tel0.ecore open abstract class Exp { abstract def String print () } open class LitVal { override String print () { obj . value . toString } } open class Sum { override String print () { rev . $ ( obj . lhs ) . print () + + + rev . $ ( obj . rhs ) . print () } } This definition requires a few explanations. Line 1: Definition of the name of the semantics. Pretty much similar to a package definition. Line 3: Import of the abstract syntax. It defines the set of class on which we are able to define operations. Lines 5-7: Definition of the print operation on the Exp abstract class. As with every object-oriented language, it enforce that each child of Exp must provide a concrete implementation of the print method. Lines 9-13: Definition of the print operation for the LitVal class. We want use the toString operation to convert the long value to a string. But we are defining the pretty print semantics externally, consequently we don't have a direct access to the value field of the syntax. To have access to the syntactic values from the semantics, we must use the obj field provided by Alex for every open class, before being able to convert it to a string. Lines 15-19: Definition of the print operation for the Sum class. To pretty print a sum, we need to obtains the result of the print method for the left hand side (lhs) and right hand side (rhs) fields of the Sum class. But what we have currently is the obj field which gives use access to the syntactic part of the Sum class, which contains the lhs and rhs Exp expressions. Consequently, we don't have access to the print operation on the field so far. To do so, we fist needs to converts the syntactic value to semantics operations, using the alg field, also provided by Alex for each open class. This alg fields contains an instance of the currently defined semantics, in the form of a revisitor. The revisitor provides a methods called $ which take a syntactic object (e.g. Exp, Sum, LitVal) and returns a semantic operation, with all the operations defined in the Alex semantics. For instance alg.$(obj.lhs) returns an semantic operation with a print method. The good thing is, since obj.lhs is an abstract Exp object, we don't know statically if the returned semantic object will be for a Sum or a LitVal object, still we know that the returned value will be a string that we will be able to concatenate before returning the resulting string. Conclusion So far we have defined a first semantics for TEL0, which allow to pretty print arbitrary instances of TEL0 abstract syntax.","title":"Getting Started"},{"location":"getting-started/#introduction","text":"This page introduces the main concepts of Alex by following the development of a small expression language. For more details about the language see TODO.","title":"Introduction"},{"location":"getting-started/#tel0","text":"Tiny Expression Language 0 (TEL0) is a toy expression language with two concepts: Integer Literal (e.g. 0, 1...) Sum operation (e.g. +)","title":"TEL0"},{"location":"getting-started/#abstract-syntax","text":"We define the abstract syntax using ecore. This tutorial explains in details how to use ecore to define a metamodel. In order to understand the rest of this introduction, you only need to understand that ecore is a formalism to define metamodels and allows the generation of Java code that conforms to this definition. From the definition of TEL0, we define the following ecore model: We introduce the Exp abstract class in order to allow the recursive definition of sums (e.g. 1 + 2 + 3 + 4). From this metamodel definition we generate, using EMF, a set of java classes.","title":"Abstract Syntax"},{"location":"getting-started/#revisitor","text":"In addition to the set of java class, Alex offers the generation of a abstract, visitor-like, interface called a Revisitor . To understand this tutorial, and to use Alex, it is not required to understand the Revisitor mechanism. Just know that it's generation is required in order to be able to define a semantics on top of the abstract syntax. The interested reader can consult the revisitor page to understand the internal details.","title":"Revisitor"},{"location":"getting-started/#semantics","text":"Once we have defined the abstract syntax of our language, we want to give it some meaning. The good news is, using Alex it is easy to define multiple meanings to a single abstract syntax in a modular way. We will show how to add a pretty printer and an evaluation semantics for TEL0.","title":"Semantics"},{"location":"getting-started/#a-pretty-printer","text":"The pretty printer is a simple way to transform the object graph of an instance of the abstract syntax to a user readable string. For instance Add (LitVal(1), Add(LitVal(2), LitVal(3))) will be pretty printed to \"1 + 2 + 3\". The following Alex program is the definition of the pretty print semantics for TEL0. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 behavior prettyprint import ecore platform:/resource/tel0.model/model/tel0.ecore open abstract class Exp { abstract def String print () } open class LitVal { override String print () { obj . value . toString } } open class Sum { override String print () { rev . $ ( obj . lhs ) . print () + + + rev . $ ( obj . rhs ) . print () } } This definition requires a few explanations. Line 1: Definition of the name of the semantics. Pretty much similar to a package definition. Line 3: Import of the abstract syntax. It defines the set of class on which we are able to define operations. Lines 5-7: Definition of the print operation on the Exp abstract class. As with every object-oriented language, it enforce that each child of Exp must provide a concrete implementation of the print method. Lines 9-13: Definition of the print operation for the LitVal class. We want use the toString operation to convert the long value to a string. But we are defining the pretty print semantics externally, consequently we don't have a direct access to the value field of the syntax. To have access to the syntactic values from the semantics, we must use the obj field provided by Alex for every open class, before being able to convert it to a string. Lines 15-19: Definition of the print operation for the Sum class. To pretty print a sum, we need to obtains the result of the print method for the left hand side (lhs) and right hand side (rhs) fields of the Sum class. But what we have currently is the obj field which gives use access to the syntactic part of the Sum class, which contains the lhs and rhs Exp expressions. Consequently, we don't have access to the print operation on the field so far. To do so, we fist needs to converts the syntactic value to semantics operations, using the alg field, also provided by Alex for each open class. This alg fields contains an instance of the currently defined semantics, in the form of a revisitor. The revisitor provides a methods called $ which take a syntactic object (e.g. Exp, Sum, LitVal) and returns a semantic operation, with all the operations defined in the Alex semantics. For instance alg.$(obj.lhs) returns an semantic operation with a print method. The good thing is, since obj.lhs is an abstract Exp object, we don't know statically if the returned semantic object will be for a Sum or a LitVal object, still we know that the returned value will be a string that we will be able to concatenate before returning the resulting string.","title":"A pretty printer"},{"location":"getting-started/#conclusion","text":"So far we have defined a first semantics for TEL0, which allow to pretty print arbitrary instances of TEL0 abstract syntax.","title":"Conclusion"},{"location":"installation/","text":"Update Site Please follow the instruction below using Alex update site: https://manuelleduc.github.io/alex/updates/ .","title":"Installation"},{"location":"installation/#update-site","text":"Please follow the instruction below using Alex update site: https://manuelleduc.github.io/alex/updates/ .","title":"Update Site"},{"location":"revisitor/","text":"TEL0 example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 interface Tel0Revisitor ExpT , IntLitT extends ExpT , SumT extends ExpT { IntLitT intLit ( final IntLit it ); SumT sum ( final Sum it ); default ExpT $ ( final Exp it ) { if ( it . getClass () == IntLitImpl . class ) return intLit (( IntLit ) it ); if ( it . getClass () == SumImpl . class ) return sum (( Sum ) it ); return null ; } default IntLitT $ ( final IntLit it ) { return intLit ( it ); } default SumT $ ( final Sum it ) { return sum ( it ); } }","title":"Revisitor"},{"location":"revisitor/#tel0-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 interface Tel0Revisitor ExpT , IntLitT extends ExpT , SumT extends ExpT { IntLitT intLit ( final IntLit it ); SumT sum ( final Sum it ); default ExpT $ ( final Exp it ) { if ( it . getClass () == IntLitImpl . class ) return intLit (( IntLit ) it ); if ( it . getClass () == SumImpl . class ) return sum (( Sum ) it ); return null ; } default IntLitT $ ( final IntLit it ) { return intLit ( it ); } default SumT $ ( final Sum it ) { return sum ( it ); } }","title":"TEL0 example"},{"location":"updates/","text":"Please follow the installation instructions","title":"Update Site"}]}