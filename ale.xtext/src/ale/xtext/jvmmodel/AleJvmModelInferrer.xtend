/*
 * generated by Xtext 2.12.0
 */
package ale.xtext.jvmmodel

import ale.utils.AleUtils
import ale.utils.EcoreUtils
import ale.utils.NamingUtils
import ale.xtext.ale.AbstractMethod
import ale.xtext.ale.AleClass
import ale.xtext.ale.AleFactory
import ale.xtext.ale.ConcreteMethod
import ale.xtext.ale.Root
import com.google.inject.Inject
import java.util.List
import org.eclipse.emf.codegen.ecore.genmodel.GenClass
import org.eclipse.emf.codegen.ecore.genmodel.GenModel
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.xtend.lib.annotations.Data
import org.eclipse.xtext.common.types.JvmTypeReference
import org.eclipse.xtext.common.types.TypesFactory
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder

class AleJvmModelInferrer extends AbstractModelInferrer {
	Root root
	EPackage pkg
	GenModel gm
	List<ResolvedClass> resolved = newArrayList
	@Inject extension JvmTypesBuilder
	@Inject extension EcoreUtils
	@Inject extension NamingUtils
	@Inject extension AleUtils
	
	@Data
	static class ResolvedClass {
		AleClass aleCls
		EClass eCls
		GenClass genCls
	}

	private def void preProcess() {
		val rs = new ResourceSetImpl
		pkg = root.importEcore.ref.loadEPackage
		gm = root.importEcore.ref.loadCorrespondingGenmodel
		
		// Create missing AleClasses
		pkg.allClasses.forEach[eCls |
			if (!root.classes.exists[name == eCls.name])
				root.classes += AleFactory::eINSTANCE.createAleClass => [
					name = eCls.name
				]
		]

		root.classes
			.sortWith[c1, c2 |
				if (c1.name < c2.name) -1
				else 1
			]
			.forEach[aleCls |
				val eCls = pkg.allClasses.findFirst[name == aleCls.name]
				val genCls = eCls.getGenClass(gm)
				resolved += new ResolvedClass(aleCls, eCls, genCls)
			]		
	} 

	def dispatch void infer(Root modelRoot, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		root = modelRoot

		preProcess()

//		inferRevisitorInterface(acceptor)
		inferRevisitorImplementation(acceptor)
		
		resolved.forEach[
			inferOperationInterface(acceptor)
			inferOperationImplementation(acceptor)
		]
	}

	private def void inferRevisitorInterface(IJvmDeclaredTypeAcceptor acceptor) {
		acceptor.accept(root.toClass(pkg.revisitorInterfaceFqn))[
			val denotations = newArrayList
			val dispatch = newArrayList
			
			interface = true

			typeParameters +=
				resolved.map[r |
					TypesFactory::eINSTANCE.createJvmTypeParameter => [
						name = r.eCls.typeParamName
					]
				]

			resolved
				.filter[eCls.ESuperTypes.size == 1]
				.forEach[r |
					val superTypeParameter = typeParameters.findFirst[tp | tp.name == r.eCls.ESuperTypes.head.typeParamName] 
					typeParameters
						.findFirst[name == r.eCls.typeParamName]
						.constraints += TypesFactory::eINSTANCE.createJvmUpperBound => [
							typeReference = typeRef(superTypeParameter)
						]
			]

			resolved.forEach[r |
				val typeParam = typeParameters.findFirst[name == r.eCls.typeParamName]

				superTypes +=
					pkg.directReferencedPkgs.map[p |
						p.revisitorInterfaceFqn.typeRef
					]
				
				if (r.eCls.EPackage == pkg && !r.eCls.abstract) {
					denotations += r.aleCls.toMethod(r.eCls.denotationName, typeParam.typeRef)[
						abstract = true
						parameters += r.aleCls.toParameter("it", typeRef(r.genCls.qualifiedInterfaceName))
					]

					denotations +=
						r.eCls.EAllSuperTypes.map[parent |
							r.aleCls.toMethod(parent.getDenotationName(r.eCls), typeParam.typeRef)[
								abstract = true
								parameters += r.aleCls.toParameter(r.eCls.varName, r.genCls.qualifiedInterfaceName.typeRef)
							]
						]
				}

				dispatch += r.aleCls.toMethod("$", typeParam.typeRef)[
					^default = true
					parameters += r.aleCls.toParameter("it", typeRef(r.genCls.qualifiedInterfaceName))
					body = '''
						«FOR subClass : r.eCls.getSubClasses(resolved.map[eCls]).filter[!abstract]»
							«val subGenCls = subClass.getGenClass(gm)»
							«val pkgFqn = subGenCls.genPackage.qualifiedPackageInterfaceName»
							«val clsID = pkgFqn + "." + subGenCls.classifierID»
							if (it.getClass() == «subGenCls.qualifiedInterfaceName».class)
								«IF subClass.ESuperTypes.size <= 1»
									return «subClass.denotationName»((«subGenCls.qualifiedInterfaceName») it);
								«ELSE»
									return «r.eCls.getDenotationName(subClass)»((«subGenCls.qualifiedInterfaceName») it);
								«ENDIF»
						«ENDFOR»
						«IF r.eCls.abstract»
							return null;
						«ELSE»
							return «r.eCls.denotationName»(it);
						«ENDIF»	
					'''
				]
			]
			
			members += denotations
			members += dispatch
		]
	}

	private def void inferRevisitorImplementation(IJvmDeclaredTypeAcceptor acceptor) {
		acceptor.accept(root.toClass(root.revisitorInterfaceFqn))[
			interface = true
			
			superTypes +=
				pkg.revisitorInterfaceFqn.typeRef(
					resolved.map[aleCls.operationInterfaceFqn.typeRef]
				)

			superTypes += root.importsAle.map[ref].map[revisitorInterfaceFqn.typeRef]

			resolved
				.filter[!eCls.abstract]
				.forEach[r |
					members += r.aleCls.toMethod(r.eCls.denotationName, r.aleCls.operationInterfaceFqn.typeRef)[
						annotations += Override.annotationRef
						parameters += r.aleCls.toParameter(r.eCls.varName, r.genCls.qualifiedInterfaceName.typeRef)
						body = '''
							return new «r.aleCls.operationImplFqn»(«r.eCls.varName», this);
						'''
					]
					
					r.eCls.EAllSuperTypes.forEach[cls |
						members += r.aleCls.toMethod(cls.getDenotationName(r.eCls), r.aleCls.operationInterfaceFqn.typeRef)[
							annotations += Override.annotationRef
							parameters += r.aleCls.toParameter(r.eCls.varName, r.genCls.qualifiedInterfaceName.typeRef)
							body = '''
								return new «r.aleCls.operationImplFqn»(«r.eCls.varName», this); 
							'''
						]
					]
				]
		]
	}

	private def void inferOperationInterface(ResolvedClass r, IJvmDeclaredTypeAcceptor acceptor) {
		acceptor.accept(r.aleCls.toClass(r.aleCls.operationInterfaceFqn))[
			interface = true
			superTypes += r.eCls.ESuperTypes.map[getMatchingAleClass(root).operationInterfaceFqn.typeRef]

			members += r.aleCls.methods.map[m |
				m.toMethod(m.name, m.type)[
					abstract = true
					parameters += m.params
				]
			]
		]
	}
	
	private def void inferOperationImplementation(ResolvedClass r, IJvmDeclaredTypeAcceptor acceptor) {
		acceptor.accept(r.aleCls.toClass(r.aleCls.operationImplFqn))[
			abstract = r.aleCls.abstract

			superTypes += r.aleCls.operationInterfaceFqn.typeRef

			members += r.aleCls.toField("obj", r.genCls.qualifiedInterfaceName.typeRef)
			members += r.aleCls.toField("alg", algSignature)
			
			members +=
				r.eCls.ESuperTypes
				.map[getMatchingAleClass(root)]
				.filter[!abstract]
				.map[parentAle |
					parentAle.toField(parentAle.rootName + "delegate", parentAle.operationInterfaceFqn.typeRef)
				]

			members += r.aleCls.toConstructor()[
				parameters += r.aleCls.toParameter("obj", r.genCls.qualifiedInterfaceName.typeRef)
				parameters += r.aleCls.toParameter("alg", algSignature)

				body = '''
					this.obj = obj;
					this.alg = alg;
					«FOR parent : r.eCls.ESuperTypes.map[getMatchingAleClass(root)].filter[!abstract]»
						this.«parent.rootName»delegate = new «parent.operationImplFqn»(obj, alg);
					«ENDFOR»
				'''
			]

			members +=
				r.aleCls.getAllMethods(true).map[m |
					m.toMethod(m.name, m.type)[
						abstract = m instanceof AbstractMethod
						annotations += Override.annotationRef
						parameters += m.params
						
						if (m instanceof ConcreteMethod)
							body = m.block
					]
				]
		]
	}

	private def JvmTypeReference getAlgSignature() {
		return typeRef(
			pkg.revisitorInterfaceFqn,
			resolved.map[aleCls.operationInterfaceFqn.typeRef]
		)
	}
}
