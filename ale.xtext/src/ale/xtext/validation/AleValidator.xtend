/*
 * generated by Xtext 2.10.0
 */
package ale.xtext.validation

import ale.utils.AleUtils
import ale.utils.EcoreUtils
import ale.xtext.ale.AbstractMethod
import ale.xtext.ale.AleClass
import ale.xtext.ale.AlePackage
import ale.xtext.ale.ConcreteMethod
import ale.xtext.ale.ImportEcore
import ale.xtext.ale.Root
import com.google.inject.Inject
import java.util.List
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AleValidator extends AbstractAleValidator {
	@Inject XtextResourceSet rs
	@Inject extension EcoreUtils
	@Inject extension AleUtils

	String SYNTAX_URI_NOT_FOUND = "syntax.uri.not.found"
	String SEMANTICS_IMPORT_LOOP = "semantics.import.loop"
	String ALE_CLASS_NAME_ERROR = "ale.class.name"
	String ALE_IMPORT_MISSING_ERROR = "ale.import.missing"
	static final String ABSTRACT_METHOD_NOT_IMPL = "ABSTRACT_METHOD_NOT_IMPL"
	static final String NO_ABSTRACT_METHOD_IF_NO_SUBCLASS = "NO_ABSTRACT_METHOD_IF_NO_SUBCLASS"

	/**
	 * TODO
	 * Check non cyclic inheritance of the semantics
	 * Check non conflicting ecore classnames
	 */

	@Check
	def checkValidSyntax(ImportEcore syntax) {
		val ePackage = syntax.ref.loadEPackage
		if (ePackage == null) {
			error(
				"Package path can't be resolve",
				syntax,
				AlePackage.Literals.IMPORT_ECORE__REF,
				SYNTAX_URI_NOT_FOUND
			)
		}
	}

	private def void loadAllSemantics(Root root, List<Root> sems) {
		val List<Root> ales = root.importsAle.map[ref]
		for (ale : ales) {
			if (!sems.contains(ale)) {
				sems.add(ale)
				ale.loadAllSemantics(sems)
			}
		}
	}

	@Check
	def checkImportSemanticNonCyclic(Root root) {
		val recDeps = newArrayList()
		root.loadAllSemantics(recDeps)
		if (recDeps.contains(root)) {
			error("Ale dependencies loop", root, AlePackage.Literals.ROOT__NAME, SEMANTICS_IMPORT_LOOP)
		}
	}
	
	/**
	 * Validates that the syntactic domain of the ale parents is a subset of the one defined for the current Ale file
	 */
//	@Check
//	def checkAleExtendsMatchesSyntactically(ImportAle importAle) {
//		val root = EcoreUtil2.getRootContainer(importAle) as Root
//		val allClasses = root.importsEcore.map[rs.loadEPackage(ref)].allClasses
//		val allImportedClasses = importAle.ref.importsEcore.map[rs.loadEPackage(ref)].allClasses
//		
//		val missingEPackages = allImportedClasses.filter[!allClasses.contains(it)]
//		if(!missingEPackages.empty) {
//			error('''Missing EPackages: «FOR missing:missingEPackages SEPARATOR ', '»«missing.name»«ENDFOR» 
//			
//			«allClasses»
//			
//			«allImportedClasses»
//			
//			''', importAle, 
//				AlePackage.Literals.IMPORT_ALE__REF, ALE_IMPORT_MISSING_ERROR
//			)
//		}
//	}
	
	
	/**
	 * Check if the name of the open class matches the name of an imported EClass element
	 */
	@Check
	def checkIsOpenClassImported(AleClass aleClass) {
		val roots = aleClass.root.getAllParents(true)
		val pkgs = roots.map[importEcore?.ref].filterNull.map[loadEPackage].toList
		val allClasses = pkgs.allClasses

		if (!allClasses.exists[name == aleClass.name])
			error("Cannot find corresponding EClass " + aleClass.name, aleClass, 
				AlePackage.Literals.ALE_CLASS__NAME, ALE_CLASS_NAME_ERROR
			)
	}

	@Check
	def void checkNoAbstractMethodsIfNoSubclasses(AleClass aleCls) {
		val root = aleCls.root
		val eCls = aleCls.getMatchingEClass

		if (!root.allEClasses.exists[ESuperTypes.contains(eCls)]) {
			aleCls.methods.filter(AbstractMethod).forEach[m |
				error("The method " + m.name + " cannot be abstract as there are no subclasses to implement it.",
					m, 
					AlePackage.Literals.METHOD__NAME,
					NO_ABSTRACT_METHOD_IF_NO_SUBCLASS
				)
			]
		}
	}

	// New validation rules
	@Check
	def void checkAbstractMethodsAreImplemented(AleClass aleCls) {
		val root = aleCls.root
		val eCls = aleCls.getMatchingEClass

		if (!root.allEClasses.exists[ESuperTypes.contains(eCls)]) {
			val abst = aleCls.allMethods.filter(AbstractMethod)
			
			val notImpl =
				abst.filter[am |
					!aleCls.allMethods
					.filter(ConcreteMethod)
					.exists[cm | cm != am && cm.overrides(am)]
				]

			if (!notImpl.empty)
				error(aleCls.name + " must implement the following inherited abstract methods: " + notImpl.map[name].join(", "),
					aleCls, 
					AlePackage.Literals.ALE_CLASS__NAME,
					ABSTRACT_METHOD_NOT_IMPL
				)
		}
	}
}
