/*
 * generated by Xtext 2.10.0
 */
package ale.xtext.validation

import ale.xtext.ale.AbstractMethod
import ale.xtext.ale.AleClass
import ale.xtext.ale.AlePackage
import ale.xtext.ale.ConcreteMethod
import ale.xtext.ale.EcoreImport
import ale.xtext.ale.Root
import ale.xtext.utils.AleUtils
import ale.xtext.utils.EcoreUtils
import com.google.inject.Inject
import java.util.List
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AleValidator extends AbstractAleValidator {
	@Inject extension EcoreUtils
	@Inject extension AleUtils

	String SYNTAX_URI_NOT_FOUND = "syntax.uri.not.found"
	String SEMANTICS_IMPORT_LOOP = "semantics.import.loop"
	String ALE_CLASS_NAME_ERROR = "ale.class.name"
	static final String ABSTRACT_METHOD_NOT_IMPL = "ABSTRACT_METHOD_NOT_IMPL"
	static final String NO_ABSTRACT_METHOD_IF_NO_SUBCLASS = "NO_ABSTRACT_METHOD_IF_NO_SUBCLASS"
	static final String ALECLASS_NAME_UNIQUENESS = "ALECLASS_NAME_UNIQUENESS"

	/**
	 * TODO
	 * Check non cyclic inheritance of the semantics
	 * Check non conflicting ecore classnames
	 */

	@Check
	def void checkValidSyntax(EcoreImport syntax) {
		val ePackage = syntax.uri.loadEPackage
		if (ePackage === null) {
			error(
				"Package path can't be resolve",
				syntax,
				AlePackage.Literals.ECORE_IMPORT__URI,
				SYNTAX_URI_NOT_FOUND
			)
		}
	}

	private def void loadAllSemantics(Root root, List<Root> sems) {
		val List<Root> ales = root.aleImports.map[ref]
		for (ale : ales) {
			if (!sems.contains(ale)) {
				sems.add(ale)
				ale.loadAllSemantics(sems)
			}
		}
	}

	@Check
	def void checkImportSemanticNonCyclic(Root root) {
		val recDeps = newArrayList()
		root.loadAllSemantics(recDeps)
		if (recDeps.contains(root)) {
			error("Ale dependencies loop", root, AlePackage.Literals.ROOT__NAME, SEMANTICS_IMPORT_LOOP)
		}
	}

	/**
	 * Check if the name of the open class matches the name of an imported EClass element
	 */
	@Check
	def void checkIsOpenClassImported(AleClass aleClass) {
		val roots = aleClass.root.getAllParents(true)
		val pkgs = roots.map[ecoreImport?.uri].filterNull.map[loadEPackage].toList
		val allClasses = pkgs.allClasses

		if (!allClasses.exists[name == aleClass.name])
			error("Cannot find corresponding EClass " + aleClass.name, aleClass,
				AlePackage.Literals.ALE_CLASS__NAME, ALE_CLASS_NAME_ERROR
			)
	}

	@Check
	def void checkNoAbstractMethodsIfNoSubclasses(AleClass aleCls) {
		val root = aleCls.root
		val eCls = aleCls.getMatchingEClass

		if (!root.allEClasses.exists[ESuperTypes.contains(eCls)]) {
			aleCls.methods.filter(AbstractMethod).forEach[m |
				error("The method " + m.name + " cannot be abstract as there are no subclasses to implement it.",
					m,
					AlePackage.Literals.ALE_METHOD__NAME,
					NO_ABSTRACT_METHOD_IF_NO_SUBCLASS
				)
			]
		}
	}

	// New validation rules
	@Check
	def void checkAleClassUniqueness(AleClass aleCls) {
		if (aleCls.root.classes.exists[aleCls != it && name == aleCls.name])
			error("Duplicate open-class " + aleCls.name + " in " + aleCls.root.name,
				aleCls,
				AlePackage.Literals.ALE_CLASS__NAME,
				ALECLASS_NAME_UNIQUENESS
			)
	}

	@Check
	def void checkAbstractMethodsAreImplemented(AleClass aleCls) {
		val root = aleCls.root
		val eCls = aleCls.getMatchingEClass

		if (!root.allEClasses.exists[ESuperTypes.contains(eCls)]) {
			val abst = aleCls.getAllMethods(true).filter(AbstractMethod)

			val notImpl =
				abst.filter[am |
					!aleCls.getAllMethods(true)
					.filter(ConcreteMethod)
					.exists[cm | cm != am && cm.overrides(am)]
				]

			if (!notImpl.empty)
				error(aleCls.name + " must implement the following inherited abstract methods: " + notImpl.map[name].join(", "),
					aleCls,
					AlePackage.Literals.ALE_CLASS__NAME,
					ABSTRACT_METHOD_NOT_IMPL
				)
		}
	}
}
